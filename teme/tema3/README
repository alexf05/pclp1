For this project, I choose to separate my code in diffefrent files to a better understanding and modularization. In the "main.c" file, we work with the input; my while loop stop if it will stop if we write "EXIT" and it is loaded an image, or if the input is readed all (if is in a file). For each command, I have a function in another file to prelucrate the image. 
For "LOADING", we freed the memory if it is a image there, and we read another one. I choose a convention to set "image.color" (which can be 1/2/3- for black and white, gray scale, and rgb images) -1, if a image is blank. In "read.c", I separete the name of the file input and try to read it in text format. If it is not a P1/P2/P3 file and means it can be a binary format P4/P5/P6. If it is not that either, it could be a empty file and I print a erorr message for the user.
For the image, i choose to create a struct with all the informations, width, height, type of image, maximum value, the zone selected and the matrix with the information, witch we will allocate later. This matrix is "unsigned char" to be stored on 1 octet without sign. This helped me to use the same matrix for binary and ascii reading and wrtiting.
For reading width, height and max value and for the ascii type even the matrix, I had in mind that my line could be a comment and start with '#' and i should ignore it.
For reading the grey and rgb images, because i needed to read with a while, i choose a system with a variable that show where i was with reading.
For the binary reading, it was simpler, because we could not have comments and we could read with "fread".
At save funtion, I detected if it shows "ascii" for text format or binary. The saving is pretty much straight foward, we print an error message if no image is loaded, otherwise, we print the information about the image.
For select command, i detect if is shows all for reset the coordonates, or if has exacty 4 numbers that could be corners for a selected portion of the image.
For crop, i rewrite selected portion with the left upper corner being (0,0). After that, i free the memory i don't need anymore, and initialize the dimentions and seleted part.
Rotating command was one the hardest. On the first hand we need to verify if the selected part is entire image or just a squre part. If it is the entire image and the angle is 90 or 270 i neded to allocate the finaly matrix with width and height inversed.
With some simple math, I could figure it out a formula for the index of the matrix for all the angles, witch i could use to copy from the temporary matrix the pixels.
For the histogram, i've calculated the distance of the intervals as image max value + 1 / numbers of intervals (y). I created an arrary for storing the numbers of appeareces of pixels in that interval. For the end i calculated the numbers of stars and print those as the requirement said.
For the "EQUALIZE" i calculated numbers of appearence of each grey pixel and after that i transform the array to each value to represent the sum from 0 to that value. After that, i changed the matrix with the formula given.
Lastly, for the "APPLY" command, each filter goes with a index of a coefficient, (i.e. "EDGE" goes with coeff[0]). More than that, i made an index double array to simulate the 9 neighbours. Now, i created a new matrix and if i need/can (if it is not on the borders) to apply filter, i add to the new value coeff[filter] * neighbour corespondly. For the last step, i clamped the value with the interval 0..max value. 